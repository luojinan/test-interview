<!-- Generated by SpecStory -->

# 完善页面交互和UI设计 (2025-06-07 15:58:12)

_**User**_

我们继续完善页面交互的细节，首页默认选择第一个分类，默认折叠所有答案，点击展开，在PC端时可以使用左右两栏布局，但是移动端必须一栏布局，要求充分使用组件库，做出漂亮、现代、扁平风格的UI界面

---

_**Assistant**_



---

[MODE: PLAN]

初始分析表明用户请求最适合PLAN阶段。协议将在PLAN模式下启动。

根据您提出的详细UI交互需求，我将制定完整的实现方案。基于现有的技术栈分析，需要创建响应式的两栏/单栏布局，实现现代扁平风格的题库界面。

## 详细实现计划

### 核心UI交互需求整合：
1. **默认状态**：首页选择第一个分类，所有答案折叠
2. **响应式布局**：PC端左右两栏，移动端单栏
3. **现代扁平风格**：充分利用daisyUI组件库
4. **交互体验**：点击展开/折叠答案

### 技术实现方案：

**响应式布局策略**：
- PC端(lg及以上)：左侧分类导航栏(固定宽度) + 右侧题目区域(自适应)
- 移动端(md及以下)：顶部分类tabs + 下方题目列表(单栏)

**组件设计方案**：
- 使用daisyUI的drawer组件实现PC侧边栏
- 使用tabs组件实现移动端分类切换
- 使用collapse组件实现题目折叠交互
- 使用card组件包装题目内容
- 集成theme-controller实现主题切换

### 实现文件计划：

```
[Change Plan]
- File: src/components/InterviewBank/CategorySidebar.vue
- Rationale: 创建PC端左侧分类导航栏组件，支持分类选择和主题切换

[Change Plan] 
- File: src/components/InterviewBank/CategoryTabs.vue
- Rationale: 创建移动端顶部分类选择tabs组件

[Change Plan]
- File: src/components/InterviewBank/QuestionCard.vue  
- Rationale: 创建基于daisyUI collapse的题目卡片组件，支持展开/折叠

[Change Plan]
- File: src/components/InterviewBank/ThemeToggle.vue
- Rationale: 创建主题切换组件，使用daisyUI theme-controller

[Change Plan] 
- File: src/views/InterviewBankView.vue
- Rationale: 创建主页面视图，实现响应式两栏/单栏布局逻辑

[Change Plan]
- File: src/composables/useInterviewBank.ts  
- Rationale: 创建组合式函数管理题库状态和交互逻辑

[Change Plan]
- File: src/data/mockData.ts
- Rationale: 创建模拟题库数据，包含多个分类的题目

[Change Plan]
- File: src/types/interview.ts
- Rationale: 定义TypeScript类型接口

[Change Plan]
- File: src/router/index.ts
- Rationale: 更新路由配置，添加题库页面路由
```

### 详细设计规范：

**颜色方案**：基于daisyUI语义化颜色
- 主色调：primary/secondary
- 背景色：base-100/base-200/base-300
- 文本色：base-content
- 边框色：base-300

**组件样式标准**：
- 卡片阴影：shadow-sm到shadow-lg
- 圆角：rounded-lg统一标准
- 间距：使用4/8/12/16px标准间距
- 过渡动画：transition-all duration-200

**响应式断点**：
- sm: 640px (移动端)
- md: 768px (平板)  
- lg: 1024px (PC端两栏触发点)
- xl: 1280px (宽屏优化)

## Implementation Checklist:

1. 创建TypeScript类型定义文件(src/types/interview.ts)
2. 创建模拟数据文件(src/data/mockData.ts)  
3. 创建题库状态管理组合函数(src/composables/useInterviewBank.ts)
4. 创建主题切换组件(src/components/InterviewBank/ThemeToggle.vue)
5. 创建题目卡片组件(src/components/InterviewBank/QuestionCard.vue)
6. 创建PC端侧边栏组件(src/components/InterviewBank/CategorySidebar.vue)
7. 创建移动端分类tabs组件(src/components/InterviewBank/CategoryTabs.vue)  
8. 创建主页面视图组件(src/views/InterviewBankView.vue)
9. 更新路由配置添加题库页面
10. 测试响应式布局在不同设备上的表现
11. 验证默认选择第一个分类和折叠状态的实现
12. 优化点击交互体验和动画过渡效果

---

_**User**_

更新进plan.txt中

---

_**Assistant**_



---

[MODE: PLAN]

我将把刚才制定的详细实现计划更新到 plan.txt 文件中的相应部分。

---

```diff
  4. **数据同步需求**：是否需要云端同步功能（后期扩展）
  5. **搜索功能范围**：支持问题和答案的全文搜索
- 6. **主题定制**：是否需要超出daisyUI默认主题的自定义样式 
+ 6. **主题定制**：是否需要超出daisyUI默认主题的自定义样式
+ 
+ # Proposed Solution (Populated by INNOVATE mode)
+ [Different approaches discussed, pros/cons evaluation, final favored solution direction]
+ 
+ # Implementation Plan (Generated by PLAN mode)
+ 
+ ## 核心UI交互需求整合
+ 1. **默认状态**：首页选择第一个分类，所有答案折叠
+ 2. **响应式布局**：PC端左右两栏，移动端单栏
+ 3. **现代扁平风格**：充分利用daisyUI组件库
+ 4. **交互体验**：点击展开/折叠答案
+ 
+ ## 技术实现方案
+ 
+ ### 响应式布局策略
+ - PC端(lg及以上)：左侧分类导航栏(固定宽度) + 右侧题目区域(自适应)
+ - 移动端(md及以下)：顶部分类tabs + 下方题目列表(单栏)
+ 
+ ### 组件设计方案
+ - 使用daisyUI的drawer组件实现PC侧边栏
+ - 使用tabs组件实现移动端分类切换
+ - 使用collapse组件实现题目折叠交互
+ - 使用card组件包装题目内容
+ - 集成theme-controller实现主题切换
+ 
+ ### 实现文件计划
+ 
+ **文件变更列表：**
+ 
+ - **File**: src/components/InterviewBank/CategorySidebar.vue
+   - **Rationale**: 创建PC端左侧分类导航栏组件，支持分类选择和主题切换
+ 
+ - **File**: src/components/InterviewBank/CategoryTabs.vue
+   - **Rationale**: 创建移动端顶部分类选择tabs组件
+ 
+ - **File**: src/components/InterviewBank/QuestionCard.vue
+   - **Rationale**: 创建基于daisyUI collapse的题目卡片组件，支持展开/折叠
+ 
+ - **File**: src/components/InterviewBank/ThemeToggle.vue
+   - **Rationale**: 创建主题切换组件，使用daisyUI theme-controller
+ 
+ - **File**: src/views/InterviewBankView.vue
+   - **Rationale**: 创建主页面视图，实现响应式两栏/单栏布局逻辑
+ 
+ - **File**: src/composables/useInterviewBank.ts
+   - **Rationale**: 创建组合式函数管理题库状态和交互逻辑
+ 
+ - **File**: src/data/mockData.ts
+   - **Rationale**: 创建模拟题库数据，包含多个分类的题目
+ 
+ - **File**: src/types/interview.ts
+   - **Rationale**: 定义TypeScript类型接口
+ 
+ - **File**: src/router/index.ts
+   - **Rationale**: 更新路由配置，添加题库页面路由
+ 
+ ### 详细设计规范
+ 
+ **颜色方案**：基于daisyUI语义化颜色
+ - 主色调：primary/secondary
+ - 背景色：base-100/base-200/base-300
+ - 文本色：base-content
+ - 边框色：base-300
+ 
+ **组件样式标准**：
+ - 卡片阴影：shadow-sm到shadow-lg
+ - 圆角：rounded-lg统一标准
+ - 间距：使用4/8/12/16px标准间距
+ - 过渡动画：transition-all duration-200
+ 
+ **响应式断点**：
+ - sm: 640px (移动端)
+ - md: 768px (平板)
+ - lg: 1024px (PC端两栏触发点)
+ - xl: 1280px (宽屏优化)
+ 
+ ## Implementation Checklist:
+ 1. 创建TypeScript类型定义文件(src/types/interview.ts)
+ 2. 创建模拟数据文件(src/data/mockData.ts)
+ 3. 创建题库状态管理组合函数(src/composables/useInterviewBank.ts)
+ 4. 创建主题切换组件(src/components/InterviewBank/ThemeToggle.vue)
+ 5. 创建题目卡片组件(src/components/InterviewBank/QuestionCard.vue)
+ 6. 创建PC端侧边栏组件(src/components/InterviewBank/CategorySidebar.vue)
+ 7. 创建移动端分类tabs组件(src/components/InterviewBank/CategoryTabs.vue)
+ 8. 创建主页面视图组件(src/views/InterviewBankView.vue)
+ 9. 更新路由配置添加题库页面
+ 10. 测试响应式布局在不同设备上的表现
+ 11. 验证默认选择第一个分类和折叠状态的实现
+ 12. 优化点击交互体验和动画过渡效果
+ 
+ # Current Execution Step (Updated by EXECUTE mode when starting a step)
+ > 待开始执行第一步
+ 
+ # Task Progress (Appended by EXECUTE mode after each step completion)
+ 
+ # Final Review (Populated by REVIEW mode) 
```

---

完美！我已经成功将详细的实现计划更新到 `plan.txt` 文件中。计划包含了：

## 已更新的内容：

### 1. **核心UI交互需求**
- 默认选择第一个分类，所有答案折叠
- PC端左右两栏，移动端单栏的响应式布局
- 充分利用daisyUI组件的现代扁平风格
- 优化的点击展开/折叠交互体验

### 2. **技术实现方案**
- **响应式布局策略**：明确了PC端和移动端的不同布局方案
- **组件设计方案**：详细列出了使用的daisyUI组件类型
- **实现文件计划**：包含9个核心文件的创建和修改计划

### 3. **详细设计规范**
- **颜色方案**：基于daisyUI语义化颜色系统
- **组件样式标准**：统一的阴影、圆角、间距和动画标准
- **响应式断点**：明确的设备适配断点

### 4. **实现清单**
包含12个具体的实施步骤，从基础类型定义到最终的交互优化。

现在计划已经完整记录在 `plan.txt` 中，接下来可以按照清单逐步实施这个现代化的面试题库界面。整个方案充分利用了daisyUI组件库的优势，确保在不同设备上都能提供优秀的用户体验。

---

_**User**_

补充数据结构相关的内容到plan.txt中

---

_**Assistant**_



---

[MODE: PLAN]

基于您提供的华为软件测试面试题JSON数据样本，我需要补充和完善plan.txt中的数据结构设计，使其更符合实际的数据格式。

---

```diff
    editedAt: Date;
  }
+ ```
+ 
+ ### 1. 数据结构设计
+ 
+ #### 原始数据格式分析（基于华为面试题JSON）
+ ```typescript
+ // 原始JSON数据结构
+ interface OriginalQuestionData {
+   id: number;
+   catalogId: number;
+   subject: string;        // 题目内容
+   answer: string;         // 答案内容
+   readCount: number;      // 阅读次数
+   createTime: number[];   // 创建时间数组 [年,月,日,时,分,秒]
+   updateTime: number[];   // 更新时间数组
+   optionStatus: number;   // 选项状态
+   catalogName: string | null;  // 分类名称
+   collect: boolean;       // 收藏状态
+ }
+ 
+ // 原始分类数据结构推导
+ interface OriginalCatalogData {
+   id: number;
+   name: string;           // 分类名称
+   description?: string;
+ }
+ ```
+ 
+ #### 应用数据格式设计
+ ```typescript
+ // 应用内使用的分类接口
+ interface Category {
+   id: string;
+   name: string;           // "Linux题", "Python题", "华为软件测试题"
+   description?: string;
+   questionCount: number;  // 该分类下的题目数量
+   icon?: string;          // 分类图标
+ }
+ 
+ // 应用内使用的题目接口
+ interface Question {
+   id: string;
+   categoryId: string;
+   subject: string;        // 题目内容
+   answer: string;         // 答案内容
+   readCount: number;      // 阅读次数
+   createTime: Date;       // 创建时间
+   updateTime: Date;       // 更新时间
+   isCollected: boolean;   // 收藏状态
+   
+   // 用户编辑相关
+   isEdited: boolean;
+   editedAt?: Date;
+   originalSubject?: string;
+   originalAnswer?: string;
+   
+   // UI状态
+   isExpanded: boolean;    // 是否展开答案
+   isBookmarked: boolean;  // 是否已收藏
+ }
+ 
+ // 用户编辑记录
+ interface UserEdit {
+   questionId: string;
+   editedSubject: string;
+   editedAnswer: string;
+   editedAt: Date;
+   editType: 'subject' | 'answer' | 'both';
+ }
+ 
+ // 用户偏好设置
+ interface UserPreferences {
+   selectedCategoryId: string;
+   theme: 'light' | 'dark' | 'auto';
+   autoExpandAnswers: boolean;
+   showReadCount: boolean;
+   compactMode: boolean;
+ }
+ 
+ // 应用状态接口
+ interface InterviewBankState {
+   categories: Category[];
+   questions: Question[];
+   userEdits: UserEdit[];
+   preferences: UserPreferences;
+   currentCategoryId: string;
+   searchQuery: string;
+   isLoading: boolean;
+   error?: string;
+ }
+ ```
+ 
+ #### 数据转换方案
+ ```typescript
+ // 数据转换工具函数
+ interface DataTransformUtils {
+   // 时间数组转换为Date对象
+   arrayToDate: (timeArray: number[]) => Date;
+   
+   // 原始数据转换为应用数据
+   transformOriginalQuestion: (original: OriginalQuestionData) => Question;
+   
+   // 批量数据转换
+   transformQuestionsBatch: (original: OriginalQuestionData[]) => Question[];
+   
+   // 分类数据聚合
+   aggregateCategories: (questions: Question[]) => Category[];
+   
+   // 数据验证
+   validateQuestionData: (question: Question) => boolean;
+ }
+ ```
+ 
+ #### 数据存储方案（基于实际JSON数据）
+ ```typescript
+ // 本地存储结构
+ interface LocalStorageSchema {
+   // 原始数据缓存
+   originalData: {
+     questions: OriginalQuestionData[];
+     lastUpdated: Date;
+     version: string;
+   };
+   
+   // 用户数据
+   userData: {
+     edits: UserEdit[];
+     preferences: UserPreferences;
+     bookmarks: string[];  // 收藏的题目ID列表
+     readHistory: {
+       questionId: string;
+       lastRead: Date;
+       readCount: number;
+     }[];
+   };
+   
+   // 应用缓存
+   appCache: {
+     transformedQuestions: Question[];
+     categories: Category[];
+     lastProcessed: Date;
+   };
+ }
+ ```
+ 
+ #### 数据处理流程
+ 1. **数据加载**：从JSON文件加载原始华为面试题数据
+ 2. **数据转换**：将原始格式转换为应用内格式
+ 3. **分类聚合**：基于catalogId和catalogName生成分类列表
+ 4. **状态初始化**：设置默认的UI状态（折叠状态、选中分类等）
+ 5. **本地存储**：将转换后的数据存储到localStorage/IndexedDB
+ 6. **增量更新**：支持新数据的增量加载和合并
+ 
+ #### 示例数据转换
+ ```typescript
+ // 原始数据示例
+ const originalData: OriginalQuestionData = {
+   id: 153,
+   catalogId: 16,
+   subject: "1、下面哪个Linux命令可以一次显示一页内容？",
+   answer: "A、pause\n\nB、cat\n\nC、more\n\nD、rep\n",
+   readCount: 820,
+   createTime: [2022, 6, 10, 9, 9, 40],
+   updateTime: [2022, 6, 10, 9, 9, 40],
+   optionStatus: 0,
+   catalogName: null,
+   collect: false
+ };
+ 
+ // 转换后的应用数据
+ const transformedData: Question = {
+   id: "153",
+   categoryId: "16",
+   subject: "1、下面哪个Linux命令可以一次显示一页内容？",
+   answer: "A、pause\n\nB、cat\n\nC、more\n\nD、rep\n",
+   readCount: 820,
+   createTime: new Date(2022, 5, 10, 9, 9, 40), // 月份需要-1
+   updateTime: new Date(2022, 5, 10, 9, 9, 40),
+   isCollected: false,
+   isEdited: false,
+   isExpanded: false,
+   isBookmarked: false
+ };
  ```
  
```

---

完美！我已经成功补充了基于实际华为面试题JSON数据的详细数据结构设计到 `plan.txt` 文件中。

## 补充的关键内容包括：

### 1. **原始数据格式分析**
- 基于您提供的JSON样本，定义了 `OriginalQuestionData` 接口
- 分析了实际数据字段：id、catalogId、subject、answer、readCount、createTime数组、updateTime数组等
- 推导了分类数据结构 `OriginalCatalogData`

### 2. **应用数据格式设计**
- **增强的Category接口**：添加了questionCount、icon等实用字段
- **完整的Question接口**：包含原始数据字段 + 用户编辑字段 + UI状态字段
- **UserEdit接口**：支持编辑类型区分（题目/答案/两者）
- **UserPreferences接口**：用户偏好设置
- **InterviewBankState接口**：完整的应用状态管理

### 3. **数据转换方案**
- `DataTransformUtils` 工具函数集合
- 时间数组到Date对象的转换
- 批量数据处理和验证
- 分类数据聚合逻辑

### 4. **本地存储方案**
- `LocalStorageSchema` 分层存储结构
- 原始数据缓存 + 用户数据 + 应用缓存
- 支持版本管理和增量更新

### 5. **数据处理流程**
明确了从数据加载到存储的完整6步流程

### 6. **示例数据转换**
提供了具体的数据转换示例，包括时间处理的注意事项（月份需要-1）

这个补充的数据结构设计完全基于您提供的实际JSON数据，确保了系统能够正确处理华为软件测试面试题的数据格式，同时为用户编辑、收藏、搜索等功能提供了完整的数据支持。

现在数据结构设计已经非常完善，可以支撑整个面试题库应用的开发需求。

---

_**User**_

补充数据获取的交互方式，当前的设想是进入页面后判断indexdb中是否有缓存数据，有则不加载远程数据，无则加载数据，数据获取暂定为获取多个script标签加载多个分类的json数据内容来使用，页面在加载过程中逐一显示不同分类的数据加载过程，加载完成后显示页面

---

_**Assistant**_



---

[MODE: PLAN]

我将在plan.txt中补充详细的数据获取交互方案，包括IndexedDB缓存检查、动态script标签加载、加载进度显示等完整的数据获取流程。

---

```diff
  
  # Final Review (Populated by REVIEW mode)
+ 
+ ## 数据获取交互方案
+ 
+ ### 数据获取策略
+ **核心原则**：优先使用本地缓存，按需远程加载，渐进式数据呈现
+ 
+ ### IndexedDB缓存策略
+ ```typescript
+ interface CacheStrategy {
+   // 缓存检查逻辑
+   checkCacheExists: () => Promise<boolean>;
+   
+   // 缓存版本检查
+   checkCacheVersion: () => Promise<{
+     hasCache: boolean;
+     version: string;
+     lastUpdated: Date;
+     isExpired: boolean;
+   }>;
+   
+   // 缓存数据获取
+   getCachedData: () => Promise<{
+     categories: Category[];
+     questions: Question[];
+     totalCount: number;
+   }>;
+   
+   // 缓存数据存储
+   setCachedData: (data: any, version: string) => Promise<void>;
+ }
+ ```
+ 
+ ### 动态Script加载方案
+ ```typescript
+ interface ScriptLoadingConfig {
+   // 数据源配置
+   dataSources: {
+     [categoryId: string]: {
+       scriptUrl: string;         // JSON数据的script标签URL
+       globalVarName: string;     // 全局变量名
+       categoryName: string;      // 分类显示名称
+       priority: number;          // 加载优先级
+       essential: boolean;        // 是否为必需数据
+     };
+   };
+   
+   // 加载配置
+   loadingConfig: {
+     concurrent: number;          // 并发加载数量
+     timeout: number;            // 超时时间(ms)
+     retryCount: number;         // 重试次数
+     retryDelay: number;         // 重试延迟(ms)
+   };
+ }
+ 
+ // 示例配置
+ const defaultConfig: ScriptLoadingConfig = {
+   dataSources: {
+     'huawei-test': {
+       scriptUrl: '/data/huawei-software-test-questions.js',
+       globalVarName: 'HUAWEI_TEST_DATA',
+       categoryName: '华为软件测试题',
+       priority: 1,
+       essential: true
+     },
+     'linux-basic': {
+       scriptUrl: '/data/linux-basic-questions.js', 
+       globalVarName: 'LINUX_BASIC_DATA',
+       categoryName: 'Linux基础题',
+       priority: 2,
+       essential: true
+     },
+     'python-interview': {
+       scriptUrl: '/data/python-interview-questions.js',
+       globalVarName: 'PYTHON_INTERVIEW_DATA', 
+       categoryName: 'Python面试题',
+       priority: 3,
+       essential: false
+     }
+   },
+   loadingConfig: {
+     concurrent: 2,
+     timeout: 10000,
+     retryCount: 3,
+     retryDelay: 1000
+   }
+ };
+ ```
+ 
+ ### 加载进度UI设计
+ 
+ #### 加载状态接口
+ ```typescript
+ interface LoadingState {
+   phase: 'checking' | 'loading' | 'processing' | 'complete' | 'error';
+   totalCategories: number;
+   loadedCategories: number;
+   currentCategory?: {
+     id: string;
+     name: string;
+     status: 'pending' | 'loading' | 'success' | 'error';
+     progress: number;        // 0-100
+     questionsCount?: number;
+   };
+   categories: Array<{
+     id: string;
+     name: string;
+     status: 'pending' | 'loading' | 'success' | 'error';
+     questionsCount: number;
+     loadTime?: number;       // 加载耗时(ms)
+   }>;
+   overallProgress: number;   // 0-100
+   errorMessage?: string;
+ }
+ ```
+ 
+ #### 加载UI组件设计
+ ```vue
+ <!-- LoadingScreen.vue 组件结构 -->
+ <template>
+   <div class="loading-screen bg-base-100 min-h-screen flex flex-col justify-center items-center p-4">
+     <!-- 整体进度 -->
+     <div class="w-full max-w-md mb-8">
+       <div class="text-center mb-4">
+         <div class="loading loading-spinner loading-lg text-primary"></div>
+         <h2 class="text-xl font-semibold mt-4">{{ getPhaseText() }}</h2>
+         <p class="text-base-content/70 mt-2">{{ getPhaseDescription() }}</p>
+       </div>
+       
+       <!-- 整体进度条 -->
+       <div class="w-full bg-base-200 rounded-full h-2 mb-4">
+         <div 
+           class="bg-primary h-2 rounded-full transition-all duration-300"
+           :style="{ width: `${loadingState.overallProgress}%` }"
+         ></div>
+       </div>
+       
+       <div class="text-center text-sm text-base-content/60">
+         {{ loadingState.loadedCategories }} / {{ loadingState.totalCategories }} 分类已加载
+       </div>
+     </div>
+     
+     <!-- 分类加载详情 -->
+     <div class="w-full max-w-lg space-y-3">
+       <div 
+         v-for="category in loadingState.categories" 
+         :key="category.id"
+         class="flex items-center justify-between p-3 bg-base-200 rounded-lg"
+       >
+         <div class="flex items-center space-x-3">
+           <!-- 状态图标 -->
+           <div class="flex-shrink-0">
+             <div v-if="category.status === 'pending'" class="w-4 h-4 bg-base-300 rounded-full"></div>
+             <div v-else-if="category.status === 'loading'" class="loading loading-spinner loading-sm text-primary"></div>
+             <div v-else-if="category.status === 'success'" class="text-success">✓</div>
+             <div v-else-if="category.status === 'error'" class="text-error">✗</div>
+           </div>
+           
+           <!-- 分类信息 -->
+           <div>
+             <div class="font-medium">{{ category.name }}</div>
+             <div v-if="category.questionsCount" class="text-sm text-base-content/60">
+               {{ category.questionsCount }} 道题目
+             </div>
+             <div v-if="category.loadTime && category.status === 'success'" class="text-xs text-base-content/50">
+               耗时 {{ category.loadTime }}ms
+             </div>
+           </div>
+         </div>
+         
+         <!-- 加载时间或状态 -->
+         <div class="text-sm text-base-content/60">
+           <span v-if="category.status === 'pending'">等待中</span>
+           <span v-else-if="category.status === 'loading'">加载中</span>
+           <span v-else-if="category.status === 'success'" class="text-success">完成</span>
+           <span v-else-if="category.status === 'error'" class="text-error">失败</span>
+         </div>
+       </div>
+     </div>
+     
+     <!-- 错误信息 -->
+     <div v-if="loadingState.errorMessage" class="mt-6 w-full max-w-lg">
+       <div class="alert alert-error">
+         <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
+           <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
+         </svg>
+         <span>{{ loadingState.errorMessage }}</span>
+         <button @click="retryLoading" class="btn btn-sm btn-outline">重试</button>
+       </div>
+     </div>
+   </div>
+ </template>
+ ```
+ 
+ ### 数据获取完整流程
+ 
+ #### 流程步骤设计
+ ```typescript
+ interface DataLoadingFlow {
+   steps: Array<{
+     phase: string;
+     description: string;
+     action: () => Promise<any>;
+     onProgress?: (progress: number) => void;
+     onSuccess?: (result: any) => void;
+     onError?: (error: Error) => void;
+   }>;
+ }
+ 
+ const dataLoadingFlow: DataLoadingFlow = {
+   steps: [
+     {
+       phase: 'checking',
+       description: '检查本地缓存',
+       action: async () => {
+         const cacheInfo = await checkCacheVersion();
+         return cacheInfo;
+       }
+     },
+     {
+       phase: 'loading', 
+       description: '加载远程数据',
+       action: async () => {
+         if (hasCacheAndValid) {
+           return await getCachedData();
+         } else {
+           return await loadRemoteDataWithProgress();
+         }
+       },
+       onProgress: (progress) => {
+         updateLoadingProgress(progress);
+       }
+     },
+     {
+       phase: 'processing',
+       description: '处理数据',
+       action: async (rawData) => {
+         const transformedData = await transformAndValidateData(rawData);
+         await setCachedData(transformedData);
+         return transformedData;
+       }
+     },
+     {
+       phase: 'complete',
+       description: '初始化界面',
+       action: async (data) => {
+         await initializeAppState(data);
+         await setupDefaultCategory();
+         return data;
+       }
+     }
+   ]
+ };
+ ```
+ 
+ #### Script动态加载实现
+ ```typescript
+ interface ScriptLoader {
+   loadScript: (config: ScriptConfig) => Promise<any>;
+   loadMultipleScripts: (configs: ScriptConfig[]) => Promise<any[]>;
+   parseScriptData: (globalVarName: string) => any;
+   cleanupScript: (scriptElement: HTMLScriptElement) => void;
+ }
+ 
+ // 核心加载逻辑
+ const scriptLoader: ScriptLoader = {
+   async loadScript(config) {
+     return new Promise((resolve, reject) => {
+       const script = document.createElement('script');
+       script.src = config.scriptUrl;
+       script.async = true;
+       
+       const timeout = setTimeout(() => {
+         document.head.removeChild(script);
+         reject(new Error(`加载超时: ${config.categoryName}`));
+       }, config.timeout || 10000);
+       
+       script.onload = () => {
+         clearTimeout(timeout);
+         try {
+           const data = window[config.globalVarName];
+           if (!data) {
+             throw new Error(`数据变量未找到: ${config.globalVarName}`);
+           }
+           
+           // 清理全局变量
+           delete window[config.globalVarName];
+           document.head.removeChild(script);
+           
+           resolve({
+             categoryId: config.categoryId,
+             categoryName: config.categoryName,
+             data: data,
+             questionsCount: Array.isArray(data) ? data.length : 0
+           });
+         } catch (error) {
+           reject(error);
+         }
+       };
+       
+       script.onerror = () => {
+         clearTimeout(timeout);
+         document.head.removeChild(script);
+         reject(new Error(`加载失败: ${config.categoryName}`));
+       };
+       
+       document.head.appendChild(script);
+     });
+   },
+   
+   async loadMultipleScripts(configs) {
+     const results = [];
+     const concurrent = Math.min(configs.length, 3); // 最多3个并发
+     
+     for (let i = 0; i < configs.length; i += concurrent) {
+       const batch = configs.slice(i, i + concurrent);
+       const batchPromises = batch.map(config => 
+         this.loadScript(config).catch(error => ({ error, config }))
+       );
+       
+       const batchResults = await Promise.allSettled(batchPromises);
+       results.push(...batchResults);
+       
+       // 更新加载进度
+       const progress = Math.round(((i + batch.length) / configs.length) * 100);
+       updateLoadingProgress(progress);
+     }
+     
+     return results;
+   }
+ };
+ ```
+ 
+ ### 加载状态管理
+ 
+ #### 状态管理Hook
+ ```typescript
+ // useDataLoading.ts
+ interface UseDataLoading {
+   loadingState: Ref<LoadingState>;
+   startDataLoading: () => Promise<void>;
+   retryLoading: () => Promise<void>;
+   resetLoading: () => void;
+ }
+ 
+ export function useDataLoading(): UseDataLoading {
+   const loadingState = ref<LoadingState>({
+     phase: 'checking',
+     totalCategories: 0,
+     loadedCategories: 0,
+     categories: [],
+     overallProgress: 0
+   });
+   
+   const startDataLoading = async () => {
+     try {
+       // 1. 检查缓存
+       loadingState.value.phase = 'checking';
+       const cacheInfo = await checkCacheVersion();
+       
+       if (cacheInfo.hasCache && !cacheInfo.isExpired) {
+         // 使用缓存数据
+         const cachedData = await getCachedData();
+         await initializeWithData(cachedData);
+         loadingState.value.phase = 'complete';
+         return;
+       }
+       
+       // 2. 加载远程数据
+       loadingState.value.phase = 'loading';
+       await loadRemoteData();
+       
+       // 3. 处理完成
+       loadingState.value.phase = 'complete';
+       
+     } catch (error) {
+       loadingState.value.phase = 'error';
+       loadingState.value.errorMessage = error.message;
+     }
+   };
+   
+   return {
+     loadingState,
+     startDataLoading,
+     retryLoading: startDataLoading,
+     resetLoading: () => {
+       loadingState.value = {
+         phase: 'checking',
+         totalCategories: 0,
+         loadedCategories: 0,
+         categories: [],
+         overallProgress: 0
+       };
+     }
+   };
+ }
+ ``` 
```

---

完美！我已经成功在plan.txt中补充了完整的数据获取交互方案。这个方案涵盖了您提出的所有需求：

## 补充的核心内容：

### 1. **数据获取策略**
- **核心原则**：优先使用本地缓存，按需远程加载，渐进式数据呈现
- **IndexedDB缓存策略**：包含缓存检查、版本管理、数据获取和存储的完整接口

### 2. **动态Script加载方案**
- **ScriptLoadingConfig**：配置多个分类的JSON数据源
- **示例配置**：华为软件测试题、Linux基础题、Python面试题等
- **加载控制**：支持优先级、并发数量、超时重试等配置

### 3. **加载进度UI设计**
- **LoadingState接口**：完整的加载状态管理
- **LoadingScreen.vue组件**：基于daisyUI的现代加载界面
  - 整体进度条和分类进度显示
  - 每个分类的加载状态图标
  - 加载时间和错误处理
  - 重试功能

### 4. **数据获取完整流程**
- **4个阶段**：检查缓存 → 加载数据 → 处理数据 → 初始化界面
- **Script动态加载实现**：完整的Promise-based加载逻辑
- **错误处理和清理机制**：超时处理、全局变量清理、DOM清理

### 5. **加载状态管理**
- **useDataLoading Hook**：Vue 3 Composition API风格的状态管理
- **自动缓存检查**：有缓存且未过期则直接使用
- **渐进式加载**：实时更新加载进度和状态

## 关键特性：

✅ **智能缓存策略**：避免重复加载，提升用户体验  
✅ **渐进式加载**：逐个显示分类加载进度  
✅ **容错处理**：超时重试、错误恢复机制  
✅ **现代UI**：基于daisyUI的美观加载界面  
✅ **性能优化**：并发控制、资源清理  
✅ **类型安全**：完整的TypeScript类型定义  

这个数据获取方案完全符合您的需求，既保证了用户体验（有缓存时快速启动），又提供了清晰的加载反馈（逐个分类显示加载进度），同时具备完善的错误处理和重试机制。

---

